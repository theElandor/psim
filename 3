#include <SDL2/SDL_events.h>
#include <iostream>
#include <iterator>
#include <string>
#include <vector>
#include <thread>
#include <cstring>
#include <fstream>
#include <atomic>
#include <mutex>
#include <queue>
#include <SDL2/SDL.h>
#include <SDL2/SDL_ttf.h>
#include <boost/asio.hpp>
#include <nlohmann/json.hpp>
#include "PublicInfo.hpp" 
#include "Button.hpp"
#include "PlayerInfo.hpp"
#include "sprites.hpp"
#include "Command.hpp"
#include "DeckVisualizer.hpp"
#include "Messages.hpp"

#define BUTTON_AREA_H 50

#define BUTTON_WIDTH 120
#define BUTTON_HEIGHT 30
#define BUTTON_MARGIN 10

using boost::asio::ip::tcp;
using json = nlohmann::json;

// UI Constants
const int MARGIN = 10;

class GameClient {
private:
  boost::asio::io_context io_context;
  tcp::socket socket;
  PublicInfo info;
  std::atomic<bool> connected;

  std::vector<char> read_buffer;
  uint32_t expected_message_length;
  std::vector<CommandCode> available_commands;
  std::string last_deck;
  
  // Thread management
  std::thread network_thread;
  std::mutex data_mutex;
  
  // Message queue for UI thread
  std::queue<std::string> message_queue;
  std::mutex queue_mutex;

  std::atomic<bool> deck_parsed; 
  
public:
  PlayerInfo player_info;
  GameClient() 
  : socket(io_context), connected(false), 
    expected_message_length(0), deck_parsed(false){
    read_buffer.resize(65536); // 64KB buffer
  }
  
  ~GameClient() {
    disconnect();
    if (network_thread.joinable()) {
      network_thread.join();
    }
  }
  std::vector<Card> get_main(){
    return player_info.main; 
  } 
  void connect_to_server(const std::string& host, int port) {
    try {
      auto endpoint = tcp::endpoint(boost::asio::ip::make_address(host), port);
      socket.connect(endpoint);
      connected = true;
      
      // Start network thread
      network_thread = std::thread([this]() {
          network_loop();
      });
    } catch (const std::exception& e) {
      std::cerr << "Connection failed: " << e.what() << "\n";
      connected = false;
    }
  }
  bool check_clear_deck_parsed(){
    bool was_set = deck_parsed.load();
    if (was_set){
      deck_parsed.store(false);
    }
    return was_set;
  }
  void disconnect() {
    if (connected) {
      connected = false;
      try {
          socket.close();
      } catch (...) {}
      io_context.stop();
    }
  }

  void send_command(const Command& command) {
    if (!connected) {
      push_message("Not connected to server!");
      return;
    } 
    
    // Post the send operation to the network thread
    boost::asio::post(io_context, [this, command]() {
      try {
        // Serialize command to JSON
        nlohmann::json j;
        to_json(j, command);
        std::string json_str = j.dump();
        
        uint32_t len = htonl(static_cast<uint32_t>(json_str.size()));
        
        // Send length first
        boost::asio::write(socket, boost::asio::buffer(&len, sizeof(uint32_t)));
        // Send message
        boost::asio::write(socket, boost::asio::buffer(json_str));
          
          // push_message("Command sent: " + command.toString());
      } catch (const std::exception& e) {
        push_message("Send error: " + std::string(e.what()));
        handle_disconnect();
      }
    });
  }

  void push_message(const std::string& message) {
    std::lock_guard<std::mutex> lock(queue_mutex);
    message_queue.push(message);
  }

  bool pop_message(std::string& message) {
    std::lock_guard<std::mutex> lock(queue_mutex);
    if (message_queue.empty()) {
      return false;
    }
    message = message_queue.front();
    message_queue.pop();
    return true;
  }

  bool is_connected() const { return connected; }

  std::string open_deck(const std::string& path) {
    try {
      std::ifstream is(path);
      if (!is) {
          return "";
      }
      
      std::string contents((std::istreambuf_iterator<char>(is)),
                         std::istreambuf_iterator<char>());
      is.close();
      return contents;
    } catch (...) {
      return "";
    }
  }

  Command create_command_from_input(CommandCode code, const std::string& param = "") {
    Command cmd;
    cmd.code = code;
    
    switch (code) {      
      case CommandCode::UploadDeck: {
        std::string contents = open_deck(param); 
        if (contents.empty()) {
          push_message("Failed to load deck from: " + param);
          cmd.code = CommandCode::Invalid; // Mark as invalid
        } else {
          cmd.target = contents;
          last_deck = contents;
          push_message("[create_command_from_input]: Deck opened successfully");
        }
        break;
      }    
      default:
          break;
    } 
    return cmd;
  }

private:
  void network_loop() {
    try {
      start_read();
      io_context.run();
    } catch (const std::exception& e) {
      push_message("Network thread error: " + std::string(e.what()));
      handle_disconnect();
    }
  }

  void start_read() {
    if (!connected) return;
    // Read message length (4 bytes)
    boost::asio::async_read(socket,
      boost::asio::buffer(&expected_message_length, sizeof(uint32_t)),
      [this](boost::system::error_code ec, std::size_t length) {
        if (!ec) {
          expected_message_length = ntohl(expected_message_length);
          // Read the actual message
          boost::asio::async_read(socket,
            boost::asio::buffer(read_buffer.data(), expected_message_length),
            [this](boost::system::error_code ec, std::size_t length) {
              if (!ec) {
                std::string message(read_buffer.begin(), 
                                  read_buffer.begin() + expected_message_length);
                handle_message(message); 
                start_read(); // Continue reading
              } else {
                  handle_disconnect();
              }
            });
        } else {
            handle_disconnect();
        }
    });
  }
    
  bool parse_deck(std::string &raw_data){
    std::cout<<"parse_deck -> starting deck_parsing..."<<std::endl;
    player_info.main.clear();
    player_info.side.clear();
    std::stringstream is(raw_data);
    std::string line;
    int copies;
    bool sideboard = false;
    std::string name;
    while(true){
      if(!std::getline(is,line)){
        std::cout<<"Reached end of list.\n";
        return true;
      }
      std::stringstream is_line(line);
      is_line>>copies;
      is_line.ignore(1);
      if(!std::getline(is_line,name)){
        std::cout<<"Something went wrong during parsing.\n";
        return false;
      }
      name.pop_back(); // remove newline from card name.
      for(int i = 0; i < copies; i++){
        // add card to either sideboard or main deck
        if(sideboard)
          player_info.side.emplace_back(0, name, "", "", 0);
        else
          player_info.main.emplace_back(0, name, "", "", 0);
      }
      if((int)is.peek() == 13){
        sideboard = true;
        is.ignore(2); // ignore carriage return and newline.
      }
    } 
    return false;
  }
   
  void handle_message(const std::string& message) {
    // Push message to queue for UI thread to process
    push_message("Server: " + message);
    std::cout<<"[handle_message]: received " + message + "\n"; 
    // Handle priority updates
    if (message == MESSAGE_correct_deck_upload){
      if(parse_deck(last_deck)){
        std::cout<<"[handle_message] Parsing succeded.\n";
        deck_parsed.store(true);
      }
    } 
  }
    
  void handle_disconnect() {
    if (connected) {
        connected = false;
        push_message("Disconnected from server");
        try {
            socket.close();
        } catch (...) {}
        io_context.stop();
    }
  }
};

// Text input handling
class TextInput {
private:
  std::string text;
  bool active;
    
public:
  TextInput() : active(false) {}
  // Just handles the text addition and deletion with backspace. 
  void handle_event(SDL_Event& e) {
    if (e.type == SDL_TEXTINPUT && active) {
      text += e.text.text;
    } else if (e.type == SDL_KEYDOWN && active) {
      if (e.key.keysym.sym == SDLK_BACKSPACE && !text.empty()) {
        text.pop_back();
      }
    }
  }
 
  void set_active(bool is_active) { active = is_active; }
  bool is_active() const { return active; }
  const std::string& get_text() const { return text; }
  void clear() { text.clear(); }
};

// Console message log
class MessageLog {
private:
  std::vector<std::string> messages;
  size_t max_messages;
  
public:
  MessageLog(size_t max = 50) : max_messages(max) {}
  
  void add_message(const std::string& message) {
    messages.push_back(message);
    if (messages.size() > max_messages) {
        messages.erase(messages.begin());
    }
  }
  
  const std::vector<std::string>& get_messages() const { return messages; }
  void clear() { messages.clear(); }
};

SDL_Rect compute_main_area(int window_h, int window_w, int console_h, int input_h){
   /*
    * This function computes the Rectangle coresponding to the area that contains
    * the deck visualizer and the card renderer. It should be refactored:
    * + create a struct and set it as the function parameter
    * + make the button bar h and w dynamic
    */
   SDL_Rect main_area;

  main_area.x = 0; main_area.y=0;
  main_area.h = window_h-console_h-input_h - BUTTON_AREA_H;
  main_area.w = window_w; 
  return main_area;
}

int main() {
  int window_w = 1000;
  int window_h = 700;
  int console_h = window_h / 4;
  int input_h = console_h / 5;
  SDL_Rect main_area = compute_main_area(window_h, window_w, console_h, input_h);
  try {
    GameClient client;
    // Initialize SDL and SDL_ttf
    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
      std::cerr << "SDL could not initialize! SDL_Error: " << SDL_GetError() << "\n";
      return 1;
    }
    if (TTF_Init() == -1) {
      std::cerr << "TTF could not initialize! TTF_Error: " << TTF_GetError() << "\n";
      SDL_Quit();
      return 1;
    }
    // Create window and renderer
    SDL_Window* window = SDL_CreateWindow("Psim Client",
                                          SDL_WINDOWPOS_CENTERED,
                                          SDL_WINDOWPOS_CENTERED,
                                          window_w, window_h,
                                          SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE);
    if (!window) {
      std::cerr << "Window could not be created! SDL_Error: " << SDL_GetError() << "\n";
      TTF_Quit();
      SDL_Quit();
      return 1;
    }
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (!renderer) {
      std::cerr << "Renderer could not be created! SDL_Error: " << SDL_GetError() << "\n";
      SDL_DestroyWindow(window);
      TTF_Quit();
      SDL_Quit();
      return 1;
    }
    
    // Load font
    TTF_Font* font = TTF_OpenFont("arial.ttf", 16);
    if (!font) {
      // Try fallback font
      font = TTF_OpenFont("/usr/share/fonts/truetype/freefont/FreeMono.ttf", 16);
      if (!font) {
        std::cerr << "Failed to load font! TTF_Error: " << TTF_GetError() << "\n";
        SDL_DestroyRenderer(renderer);
        SDL_DestroyWindow(window);
        TTF_Quit();
        SDL_Quit();
        return 1;
      }
    }
 
    // ==================== Main UI components ====================
    TextInput text_input;
    MessageLog message_log;
    DeckVisualizer deck_visualizer(renderer, font, main_area);
    Button upload_button(main_area.w - BUTTON_WIDTH, main_area.h, BUTTON_WIDTH, BUTTON_HEIGHT);
    // ============================================================


    // Connect to server
    client.connect_to_server("127.0.0.1", 5000);
    message_log.add_message("Connecting to server...");
 
    // Main game loop
    bool quit = false;
    SDL_Event e;

    while (!quit) {
      // Process events
      int mouseX, mouseY;
      SDL_GetMouseState(&mouseX, &mouseY);
      // send mouse position to deck visualizer.
      deck_visualizer.mouseX = mouseX;
      deck_visualizer.mouseY = mouseY;
      while (SDL_PollEvent(&e) != 0) { // polling events from SDL
        if (e.type == SDL_QUIT) {
            quit = true;
        } else if (e.type == SDL_MOUSEBUTTONDOWN) {
            // Toggle text input focus
          SDL_Point mouse_pos = {e.button.x, e.button.y};
          SDL_Rect input_rect = {MARGIN, window_h- input_h - MARGIN, 
                               window_w - 2*MARGIN, input_h};
          text_input.set_active(SDL_PointInRect(&mouse_pos, &input_rect));
        } else if (e.type == SDL_KEYDOWN) {
          if (e.key.keysym.sym == SDLK_RETURN && text_input.is_active()) {
            // Send command
            std::string command_text = text_input.get_text();
            if (!command_text.empty()) {
              message_log.add_message("You: " + command_text); 
              // Handle special commands
              if (command_text == "quit") {
                  client.send_command(Command(CommandCode::Quit));
              } else if (command_text == "resign") {
                  client.send_command(Command(CommandCode::Resign));
              }else if (command_text.find("upload ") == 0) {
                std::string path = command_text.substr(7);
                Command cmd = client.create_command_from_input(CommandCode::UploadDeck, path);
                if (cmd.code != CommandCode::Invalid) {
                  client.send_command(cmd);                }
              } else {
                message_log.add_message("[CLIENT] Unknown command: " + command_text);
              } 
              text_input.clear();
            }
          }
        } 
        else if (e.type == SDL_WINDOWEVENT && (e.window.event == SDL_WINDOWEVENT_RESIZED || e.window.event == SDL_WINDOWEVENT_SIZE_CHANGED)){
          window_w = e.window.data1;  // updated width
          window_h = e.window.data2;  // updated height    
          // recompute
          console_h = window_h / 4;
          input_h = console_h / 5;
          // recompute main area size
          main_area = compute_main_area(window_h,window_w,console_h,input_h);
          deck_visualizer.update_display_area(main_area);
        }
        else if(e.type == SDL_MOUSEWHEEL){
          deck_visualizer.handle_scroll(e.wheel.y);
        }
        text_input.handle_event(e);
      } 
      // Process network messages
      std::string message;
      while (client.pop_message(message)) {
        message_log.add_message(message);
      } 
      if(client.check_clear_deck_parsed()){
        deck_visualizer.reset_for_new_deck();
      }
      // Clear screen
      SDL_SetRenderDrawColor(renderer, 40, 44, 52, 255);
      SDL_RenderClear(renderer); 
      // Draw game area (top section)
      SDL_SetRenderDrawColor(renderer, 30, 30, 30, 255);
      SDL_Rect game_rect = {0, 0, window_w, window_h - console_h};
      SDL_RenderFillRect(renderer, &game_rect); 
      if(client.player_info.main.size() != 0){
        deck_visualizer.renderDeck(client.player_info.main);
      }
      // Render buttons
      upload_button.render(renderer, font);
      // Draw console area
      SDL_SetRenderDrawColor(renderer, 50, 50, 50, 255);
      SDL_Rect console_rect = {0, window_h - console_h, window_w , console_h};
      SDL_RenderFillRect(renderer, &console_rect); 
      // Draw message log
      SDL_Color text_color = {255, 255, 255, 255};
      const auto& messages = message_log.get_messages();
      // Calculate available space for messages (above input box)
      int available_height = console_h - input_h - 2 * MARGIN;
      int max_lines = available_height / 20; // 20px per line

      int start_index = std::max(0, (int)messages.size() - max_lines);
      int y_pos = window_h - console_h + MARGIN;

      for (size_t i = start_index; i < messages.size(); i++) {
        // Don't render beyond the available space
        if (y_pos + 20 > window_h - input_h - MARGIN) {
            break;
        }
        render_text(renderer, font, messages[i], MARGIN, y_pos, text_color);
        y_pos += 20;
      } 
      // Draw input box
      SDL_SetRenderDrawColor(renderer, text_input.is_active() ? 100 : 70, 70, 70, 255);
      SDL_Rect input_rect = {MARGIN,window_h- input_h - MARGIN, 
                           window_w - 2*MARGIN, input_h};
      SDL_RenderFillRect(renderer, &input_rect);
      
      // Draw input text
      std::string input_text = "> " + text_input.get_text();
      if (text_input.is_active() && (SDL_GetTicks() / 500) % 2 == 0) {
          input_text += "_";
      }
      render_text(renderer, font, input_text, MARGIN + 5, window_h - input_h - MARGIN + 5, text_color);
      
      // Draw status indicators
      if (client.is_connected()) {
          SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
      } else {
          SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
      }
      SDL_Rect status_rect = {window_w - 30, 10, 20, 20};
      SDL_RenderFillRect(renderer, &status_rect);
       
      // Draw help text
      render_text(renderer, font, "Commands: upload, quit", 
               MARGIN, 10, {200, 200, 200, 255});
   
      // Present renderer
      SDL_RenderPresent(renderer);
      
      // Cap frame rate
      SDL_Delay(16);
    }
    
    // Cleanup
    client.disconnect();
    TTF_CloseFont(font);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    TTF_Quit();
    SDL_Quit();
    
} catch (std::exception& e) {
    std::cerr << "Client exception: " << e.what() << "\n";
}

return 0;
}
